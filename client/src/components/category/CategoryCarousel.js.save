/**
 * Author: iracanyes
 * Date: 11/20/18
 * Description: Carousel Categories Component
 */
import React, {Component, Fragment} from 'react';
import { connect } from 'react-redux';
import { Link } from 'react-router-dom';
import PropTypes from 'prop-types';
import { list, reset } from '../../actions/category/list';
import { success } from '../../actions/category/delete';
import { itemToLinks } from "../../utils/helpers";

/* Attention, l'oubli de la virgule après le dernier nom de composant entraîne une erreur au chargement du composant "reactstap" */
import {
    Carousel,
    CarouselItem,
    CarouselControl,
    CarouselIndicators,
    CarouselCaption,
} from 'reactstrap';
import 'bootstrap/dist/css/bootstrap.css';
import { Transition } from 'react-transition-group';

CarouselItem.propTypes = {
    ...Transition.propTypes,
    tag: PropTypes.oneOfType([PropTypes.func, PropTypes.string]),
    in: PropTypes.bool,
    cssModule: PropTypes.object,
    children: PropTypes.node,
    slide: PropTypes.bool,
};

CarouselControl.propTypes = {
    direction: PropTypes.oneOf(['prev', 'next']).isRequired,
    onClickHandler: PropTypes.func.isRequired,
    cssModule: PropTypes.object,
    directionText: PropTypes.string
};

CarouselIndicators.propTypes = {
    items: PropTypes.array.isRequired,
    activeIndex: PropTypes.number.isRequired,
    cssModule: PropTypes.object,
    onClickHandler: PropTypes.func.isRequired
};

CarouselCaption.propTypes = {
    captionHeader: PropTypes.string,
    captionText: PropTypes.string.isRequired,
    cssModule: PropTypes.object
};

class CategoryCarousel extends Component {
    static propTypes = {
        error: PropTypes.string,
        loading: PropTypes.bool.isRequired,
        data: PropTypes.object.isRequired,
        deletedItem: PropTypes.object,
        list: PropTypes.func.isRequired,
        reset: PropTypes.func.isRequired,
        // Carousel
        // Active slide
        activeIndex: PropTypes.number,
        // Avancer dans le carousel
        //next: PropTypes.func.isRequired,
        //previous: PropTypes.func.isRequired,
        // Controle si les flèches droit et gauche peuvent être utilisé
        //keyboard: PropTypes.bool,
        /* If set to "hover", pauses the cycling of the carousel on mouseenter and resumes
         * the cycling of the carousel on
         * mouseleave. If set to false, hovering over the carousel won't pause it. (default: "hover")
         */
        //pause: PropTypes.oneOf(['hover', false]),
        // Autoplays the carousel after the user manually cycles the first item. If "carousel", autoplays the carousel on load.
        // This is how bootstrap defines it... I would prefer a bool named autoplay or something...
        //ride: PropTypes.oneOf(['carousel']),
        // the interval at which the carousel automatically cycles (default: 5000)
        /*interval: PropTypes.oneOfType([
            PropTypes.number,
            PropTypes.string,
            PropTypes.bool,
        ]),
        */
        //children: PropTypes.array,
        // called when the mouse enters the Carousel
        //mouseEnter: PropTypes.func,
        // called when the mouse exits the Carousel
        //mouseLeave: PropTypes.func,
        // controls whether the slide animation on the Carousel works or not
        //slide: PropTypes.bool,
        //cssModule: PropTypes.object,

    };



    constructor(props)
    {
        super(props);
        this.state = { activeIndex: 0 };
        this.next = this.next.bind(this);
        this.previous = this.previous.bind(this);
        this.goToIndex = this.goToIndex.bind(this);
        this.onExiting = this.onExiting.bind(this);
        this.onExited = this.onExited.bind(this);
    }

    onExiting()
    {
        this.animating = true;
    }

    onExited()
    {
        this.animating = false;
    }

    next()
    {
        if(this.animating) return;
        const nextIndex = this.state.activeIndex === this.props.data['hydra:member'][0].length - 1 ? 0 : this.state.activeIndex + 1;
        this.setState({ activeIndex: nextIndex });
    }

    previous()
    {
        if(this.animating) return;
        const nextIndex = this.state.activeIndex === 0? this.props.data['hydra:member'][0].length - 1 : this.state.activeIndex - 1;
    }

    goToIndex(newIndex)
    {
        if(this.animating) return;
        this.setState({ activeIndex: newIndex });
    }

    componentDidMount()
    {
        this.props.list(this.props.page && this.props.page);
    }

    componentWillReceiveProps(nextProps)
    {
        if(this.props.page !== nextProps.page) nextProps.list(nextProps.page && nextProps.page);
    }

    componentWillUnmount()
    {
        this.props.reset();
    }

    render()
    {
        const { activeIndex } = this.state;


        const slides = this.props.data['hydra:member'][0].map((item) => {
            return (
                <CarouselItem
                    onExiting={this.onExiting}
                    onExited={this.onExited}
                    key={item.id}
                >
                    <img src={item.src} alt={item.alt} />
                    <h5>{item.name.toUpperCase()}</h5>
                </CarouselItem>
            );
        });

        return (
            <Carousel
                activeIndex={activeIndex}
                next={this.next}
                previous={this.previous}
            >
                <CarouselIndicators
                    items={this.props.data['hydra:member'][0]}
                    activeIndex={activeIndex}
                    onClickHandler={this.goToIndex}
                />
                {slides}
                <CarouselControl direction={"prev"} directionText={"Précédent"}/>
                <CarouselControl direction={"next"} directionText={"Suivant"}/>
            </Carousel>
        );
    }
}

const mapStateToProps = (state) => {
    return {
        data: state.category.list.data,
        error: state.category.list.error,
        loading: state.category.list.loading,
        deletedItem: state.category.del.deleted,
    };
};

const mapDispatchToProps = (dispatch) => {
    return {
        list: (page) => dispatch(list(page)),
        reset: () => {
            dispatch(reset());
            dispatch(success(null))
        },
    };
};

export default Carousel;